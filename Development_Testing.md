# Development Testing
During the testing stage it is very important to have a broad thinking. Testing each component, connections between componets and the system as a whole are equally esential in order to ensure that the desired requirements are fulfilled. The testing stages reduce to unit testing, integration testing and system testing.

The tests can be run either locally using our IDE's(IntelliJ) run configuration or remotely via Continuous Integration. The latter represents a great tool for developers to keep their version of code up to date, avoiding problems like merge hell.
### Continuous Integration
It was implemented using bitbucket pipelines. The main problem when setting up Continuous Integration was that the bitbucket server was timing out the drivers responsible for opening the browsers and taking the screenshot. The reason for this happening was that the remote server was not configured properly, hence the browser that the driver was trying to open was not installed. A custom docker image hosted on docker hub was ran on the server, solving the issue.
### Unit testing
Unit tests represent the lower level of testing, thus there must be plenty of them. The ones that are worth mentioning include the item creation test that checks if the item parameters are transmitted correctly and the driver tests for both Chrome and Firefox browsers. Selenium webdriver came in hand as it allows automated browser testing for multiple operating systems(Linux, Windows, MacOS).

When testing the front end, the major challenge was to check if the image thumbnail returned matches the desired webpage image. The first approach was to compare the binary files of both images. This attempt proved not to work as expected, mainly due to changes in binary files resulted from different causes including resolution changes. The final option remains to automatically launch a browser for the desired webpage using system specific drivers and to visually inspect if the images match.
### Integration testing
In the integration testing stage, the most targeted component was the ServerController. It handles different requests made by the users. The link between the front end and the back end is done via the CRUD requests. Beside Junit5, Spring MVC test framework was used in order to mock real-time requests. These tests represent the core of our testing strategy. The main challenge faced when mocking CRUD requests was that our IDE was running tests in a random order. Since a get, update or delete request was unable to perform unless the desired entry was already created in the storage environment, the post request had to be done first. Giving an order to the tests solved this issue. Another issue was that requests couldn't be made unless a user was logged in. Mocking a user wth a unique username and password fixed the issue.
### System testing
Scalability is an important aspect of our app so the emphasis in the system testing stage has fallen on this feature. Multiple levels of concurrency were tested using Apache Bench terminal commands. This was a useful tool to see how far we can push the web-server with concurrent connections and page requests load. The attached images present test reports made at different concurrency levels. The name of the image specifies the number of concurrent users as well as the total number of requests for those users. We can see that the more users we have, the more request are executed on average per second(key feature of concurrency). Passing the test with 10 users each doing 10 page hits represents a peak load for a website that gets about 100000 hits/month.
